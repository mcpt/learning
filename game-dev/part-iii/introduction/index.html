<!doctype html><html lang=en class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.94.2"><meta name=generator content="Relearn 2.9.2
"><meta name=description content><title>Introduction :: MCPT Learning Resources</title><link href=/css/nucleus.css?1647713367 rel=stylesheet><link href=/css/fontawesome-all.min.css?1647713367 rel=stylesheet><link href=/css/featherlight.min.css?1647713367 rel=stylesheet><link href=/css/perfect-scrollbar.min.css?1647713367 rel=stylesheet><link href=/css/auto-complete.css?1647713367 rel=stylesheet><link href=/css/theme.css?1647713367 rel=stylesheet><link href=/css/theme-mcpt.css?1647713367 rel=stylesheet><link href=/css/variant.css?1647713367 rel=stylesheet><link href=/css/print.css?1647713367 rel=stylesheet media=print><link href=/css/p5js.css?1647713367 rel=stylesheet><link href=/css/sidebar.css?1647713367 rel=stylesheet><script src=/js/jquery.min.js?1647713367></script><style>:root #header+#content>#left>#rlblock_left{display:none!important}</style><script src=/js/p5.min.js></script></head><body data-url=/game-dev/part-iii/introduction/><script>var index_url="/index.json",root_url="/",baseUri=root_url.replace(/\/$/,'')</script><nav id=sidebar><div id=header-wrapper><div id=header><a href=/><img src=https://mcpt.ca/static/icons/logo.png><br><span class=subheading>LEARNING</span></a></div><div class=searchbox><label for=search-by><i class="fas fa-search"></i></label>
<input data-search-input id=search-by type=search placeholder=Search...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script src=/js/lunr.min.js?1647713367></script>
<script src=/js/auto-complete.js?1647713367></script>
<script src=/js/search.js?1647713367></script></div><div id=homelinks><ul><li><a class=padding href=/><i class="fas fa-home"></i> Home</a></li></ul></div><div class=highlightable><ul class=topics><li data-nav-id=/game-dev/ title="Game Series" class="dd-item parent"><a href=/game-dev/>Game Series</a><ul><li data-nav-id=/game-dev/leaderboard/ title=Leaderboard class=dd-item><a href=/game-dev/leaderboard/>Leaderboard</a></li><li data-nav-id=/game-dev/part-i/ title="Part I" class=dd-item><a href=/game-dev/part-i/><b>1.</b> Part I</a><ul><li data-nav-id=/game-dev/part-i/introduction/ title=Introduction class=dd-item><a href=/game-dev/part-i/introduction/>Introduction</a></li><li data-nav-id=/game-dev/part-i/draganddrop/ title="Drag And Drop" class=dd-item><a href=/game-dev/part-i/draganddrop/>Drag And Drop</a></li><li data-nav-id=/game-dev/part-i/towers/ title="Rotating Towers" class=dd-item><a href=/game-dev/part-i/towers/>Rotating Towers</a></li><li data-nav-id=/game-dev/part-i/pathforballoons/ title="Path For Balloons" class=dd-item><a href=/game-dev/part-i/pathforballoons/>Path For Balloons</a></li><li data-nav-id=/game-dev/part-i/challenge/ title="Challenge: Movement" class=dd-item><a href=/game-dev/part-i/challenge/>Challenge: Movement</a></li><li data-nav-id=/game-dev/part-i/updatingballoons/ title="Balloon Waves" class=dd-item><a href=/game-dev/part-i/updatingballoons/>Balloon Waves</a></li><li data-nav-id=/game-dev/part-i/healthchecking/ title="Health Bar" class=dd-item><a href=/game-dev/part-i/healthchecking/>Health Bar</a></li><li data-nav-id=/game-dev/part-i/towervaliditychecking/ title="Tower Validity Checking" class=dd-item><a href=/game-dev/part-i/towervaliditychecking/>Tower Validity Checking</a></li></ul></li><li data-nav-id=/game-dev/part-ii/ title="Part II" class=dd-item><a href=/game-dev/part-ii/><b>2.</b> Part II</a><ul><li data-nav-id=/game-dev/part-ii/introduction/ title=Introduction class=dd-item><a href=/game-dev/part-ii/introduction/>Introduction</a></li><li data-nav-id=/game-dev/part-ii/advancedtracking/ title="Advanced Tracking" class=dd-item><a href=/game-dev/part-ii/advancedtracking/>Advanced Tracking</a></li><li data-nav-id=/game-dev/part-ii/currency/ title="Currency System" class=dd-item><a href=/game-dev/part-ii/currency/>Currency System</a></li><li data-nav-id=/game-dev/part-ii/newtower/ title="New Towers" class=dd-item><a href=/game-dev/part-ii/newtower/>New Towers</a></li><li data-nav-id=/game-dev/part-ii/projectiles/ title=Projectiles class=dd-item><a href=/game-dev/part-ii/projectiles/>Projectiles</a></li></ul></li><li data-nav-id=/game-dev/part-iii/ title="Part III" class="dd-item parent"><a href=/game-dev/part-iii/><b>3.</b> Part III</a><ul><li data-nav-id=/game-dev/part-iii/introduction/ title=Introduction class="dd-item active"><a href=/game-dev/part-iii/introduction/>Introduction</a></li><li data-nav-id=/game-dev/part-iii/currency/ title="More Currency" class=dd-item><a href=/game-dev/part-iii/currency/>More Currency</a></li><li data-nav-id=/game-dev/part-iii/upgrades/ title="Tower Upgrades" class=dd-item><a href=/game-dev/part-iii/upgrades/>Tower Upgrades</a></li><li data-nav-id=/game-dev/part-iii/userinterface/ title="User Interface" class=dd-item><a href=/game-dev/part-iii/userinterface/>User Interface</a></li><li data-nav-id=/game-dev/part-iii/makinglevels/ title="Making Levels" class=dd-item><a href=/game-dev/part-iii/makinglevels/>Making Levels</a></li><li data-nav-id=/game-dev/part-iii/pathcreationapi/ title="Path Creation API" class=dd-item><a href=/game-dev/part-iii/pathcreationapi/>Path Creation API</a></li><li data-nav-id=/game-dev/part-iii/powerups/ title=Powerups class=dd-item><a href=/game-dev/part-iii/powerups/>Powerups</a></li><li data-nav-id=/game-dev/part-iii/challenge/ title=Challenges class=dd-item><a href=/game-dev/part-iii/challenge/>Challenges</a></li></ul></li></ul></li><li data-nav-id=/game-jam/ title="Game Jam" class=dd-item><a href=/game-jam/>Game Jam</a><ul><li data-nav-id=/game-jam/leaderboard/ title=Leaderboard class=dd-item><a href=/game-jam/leaderboard/>Leaderboard</a></li><li data-nav-id=/game-jam/tetris-workshop/ title="Tetris Workshop" class=dd-item><a href=/game-jam/tetris-workshop/>Tetris Workshop</a><ul><li data-nav-id=/game-jam/tetris-workshop/object-oriented-programming/ title="Object Oriented Programming" class=dd-item><a href=/game-jam/tetris-workshop/object-oriented-programming/>Object Oriented Programming</a></li><li data-nav-id=/game-jam/tetris-workshop/multi-dimensional-arrays/ title="Multi-Dimensional Arrays" class=dd-item><a href=/game-jam/tetris-workshop/multi-dimensional-arrays/>Multi-Dimensional Arrays</a></li><li data-nav-id=/game-jam/tetris-workshop/threads/ title=Multi-Threading class=dd-item><a href=/game-jam/tetris-workshop/threads/>Multi-Threading</a></li><li data-nav-id=/game-jam/tetris-workshop/tetris/ title=Tetris class=dd-item><a href=/game-jam/tetris-workshop/tetris/>Tetris</a></li></ul></li><li data-nav-id=/game-jam/jumpingphysics/ title="Jumping Physics Workshop" class=dd-item><a href=/game-jam/jumpingphysics/>Jumping Physics Workshop</a><ul><li data-nav-id=/game-jam/jumpingphysics/collisions/ title=Collisions class=dd-item><a href=/game-jam/jumpingphysics/collisions/>Collisions</a></li><li data-nav-id=/game-jam/jumpingphysics/jumpingphysics/ title="Jumping Physics" class=dd-item><a href=/game-jam/jumpingphysics/jumpingphysics/>Jumping Physics</a></li></ul></li><li data-nav-id=/game-jam/resources/ title=Resources class=dd-item><a href=/game-jam/resources/>Resources</a><ul><li data-nav-id=/game-jam/resources/github/ title="A Github Crash Course" class="dd-item alwaysopen"><a href=/game-jam/resources/github/>A Github Crash Course</a><ul></ul></li><li data-nav-id=/game-jam/resources/devpost-info/ title="Devpost Information" class="dd-item alwaysopen"><a href=/game-jam/resources/devpost-info/>Devpost Information</a><ul></ul></li><li data-nav-id=/game-jam/resources/tips/ title="Tips & Tricks" class="dd-item alwaysopen"><a href=/game-jam/resources/tips/>Tips & Tricks</a><ul></ul></li><li data-nav-id=/game-jam/resources/pitch/ title="Pitch Creation" class="dd-item alwaysopen"><a href=/game-jam/resources/pitch/>Pitch Creation</a><ul></ul></li></ul></li></ul></li><li data-nav-id=/lyon-hacks/ title=LyonHacks class=dd-item><a href=/lyon-hacks/>LyonHacks</a><ul><li data-nav-id=/lyon-hacks/season-ii/ title="LyonHacks Season II" class="dd-item alwaysopen"><a href=/lyon-hacks/season-ii/>LyonHacks Season II</a><ul></ul></li><li data-nav-id=/lyon-hacks/legacy/ title="Legacy Events" class=dd-item><a href=/lyon-hacks/legacy/>Legacy Events</a><ul><li data-nav-id=/lyon-hacks/legacy/season-i/ title="Season I" class=dd-item><a href=/lyon-hacks/legacy/season-i/>Season I</a></li></ul></li></ul></li></ul><div id=footer><a href=https://mcpt.ca/><p><object type=image/svg+xml data=/img/footer-icon.svg></object>
mcpt.ca</p></a><a href=https://github.com/mcpt/learning><p><i class="fab fa-github-alt"></i> source</p></a></div></div></nav><div id=body><div id=overlay></div><div class="padding highlightable"><div id=top-bar><div id=breadcrumbs><span id=sidebar-toggle-span><a href=# id=sidebar-toggle data-sidebar-toggle><i class="fas fa-bars"></i></a></span>
<span id=toc-menu><i class="fas fa-list-alt"></i></span><ol class=links itemscope itemtype=http://schema.org/BreadcrumbList><meta itemprop=itemListOrder content="Descending"><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="4"><a itemprop=item href=/><span itemprop=name>Home</span></a> ></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="3"><a itemprop=item href=/game-dev/><span itemprop=name>Game Series</span></a> ></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="2"><a itemprop=item href=/game-dev/part-iii/><span itemprop=name>Part III</span></a> ></li><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><meta itemprop=position content="1"><a itemprop=item href=/game-dev/part-iii/introduction/ aria-disabled=true><span itemprop=name>Introduction</span></a></li></ol></div><div class=progress><div class=wrapper><nav id=TableOfContents><ul><li><a href=#game-dev---season-iv>Game Dev - Season IV</a><ul><li><a href=#demo>Demo</a></li><li><a href=#additional-info>Additional Info</a></li></ul></li></ul></nav></div></div></div><div id=head-tags></div><main id=body-inner><h1>Introduction</h1><hr><h2 id=game-dev---season-iv>Game Dev - Season IV</h2><p>Welcome to the return of MCPT&rsquo;s Game Dev Series! Over the course of 3 workshops, we have something for everyone, whether youâ€™re a beginner or an experienced coder. Inspired by <strong>Bloons Tower Defense</strong>, you will learn how to code your very own tower-defense game in Processing!</p><div class="notices tip"><div class=label>Challenges</div><p>Earn up to <strong>400</strong> bonus points with our open-ended challenge! Stay tuned for more info!</p></div><h3 id=demo>Demo</h3><div class=p5js-canvas id=p5js-6831749251647713367503789792-canvas title="p5.js widget"></div><script style=display:none>new p5(p=>{with(p)eval('\n// Program main method\nfunction setup() {\n    initializeFields();\n    createCanvas(800, 500);\n\n    initDragAndDrop();\n    initPath();\n    createWaves();\n}\nlet started;\nlet frames = 0;\n\nfunction draw() {\n    frames++;\n    background(color(0xad, 0xd5, 0x58));\n\n    if(!started) {\n        const sz = 40 + Math.sin(frames / 15);\n        textSize(sz);\n        textAlign(CENTER, CENTER)\n\n        rectMode(CENTER);\n        noStroke();\n        fill(color(0xed, 0xd7, 0x60));\n        rect(400, 250, sz * 9, sz * 2, 50);\n        fill(color(0xfd, 0xe7, 0x70));\n        rect(400, 250, sz * 9 - 10, sz * 2 - 10, 50);\n        fill(color(0x4C, 0x67, 0x10));\n        text("click to start! ", 408, 255);\n        return;\n    }\n    textAlign(LEFT, BASELINE)\n    background(color(0xad, 0xd5, 0x58));\n    drawPath();\n    // Draw all the towers that have been placed down before\n    drawAllTowers();\n    handleProjectiles();\n    drawTrash();\n    drawSelectedTowers();\n    dragAndDropInstructions();\n    drawCurrentSpikeIcon();\n    displayPowerups();\n    drawAllSpikes();\n    handleSlowdown();\n    handleSpeedBoost();\n    if (playingLevel) {\n        drawBalloons();\n    }\n    drawHealthBar();\n    drawBalanceDisplay();\n    drawNextLevelButton();\n    drawTowerUI();\n    /*\n  //upgrading towers implementation\n  drawUpgrade();\n  upgradeCheck();\n\n  //removing towers implementation\n  drawRemove();\n  removeCheck();\n  */\n    towerClickCheck();\n    drawRange();\n    if (health \u003c= 0) {\n        drawLostAnimation();\n    }\n}\n\n// Whenever the user drags the mouse, update the x and y values of the tower\nfunction mouseDragged() {\n    if (currentlyDragging != notDragging) {\n        dragAndDropLocations[currentlyDragging] = new p5.Vector(mouseX + difX, mouseY + difY);\n    }\n    if (spikeHeld) {\n        spikeLocation = new p5.Vector(mouseX + difX, mouseY + difY);\n    }\n}\n\n// Whenever the user initially presses down on the mouse\nfunction mousePressed() {\n    started = true;\n    for (var i = 0; i \u003c towerCount; i++) {\n        handlePickUp(i);\n    }\n    handleSpikePickUp();\n    handleSlowdownPress();\n    handleSpeedBoostPress();\n    handleNextLevel();\n}\n\n// Whenever the user releases their mouse\nfunction mouseReleased() {\n    if (currentlyDragging != notDragging) {\n        handleDrop(currentlyDragging);\n    }\n    currentlyDragging = notDragging;\n    if (spikeHeld) {\n        handleSpikeDrop();\n    }\n}\n\nvar levels;\n\nvar balloons;\n\nvar distanceTravelled, delay, speed, maxHP, hp, slowed, ID;\n\n// Radius of the balloon\nvar balloonRadius;\n\nvar levelNum;\n\nvar playingLevel;\n\n/*\nEncompasses: Displaying Balloons, Waves \u0026 Sending Balloons, Balloon Reaching End of Path\n*/\nfunction createWaves() {\n    createLevels(2);\n    // (level balloons are for, number of balloons, first balloon delay, delay between the sequence of balloons, speed, hp)\n    createBalloons(0, 5, 0, 20, 1, 20);\n    createBalloons(0, 100, 30, 20, 2, 60);\n    createBalloons(0, 1, 2020, 0, 0.6, 1000);\n    createBalloons(1, 5, 0, 20, 1, 100);\n}\n\nfunction createLevels(num) {\n    for (var i = 0; i \u003c num; i++) {\n        levels.push([]);\n    }\n}\n\nfunction createBalloons(level, numBalloons, delay, delayInBetween, speed, hp) {\n    for (var i = 0; i \u003c numBalloons; i++) {\n        console.log(level + " " + (delay + i * delayInBetween));\n        levels[level].push( [ 0, delay + i * delayInBetween, speed, hp, hp, 0, levels[level].length ]);\n    }\n}\n\n// Displays and moves balloons\nfunction updatePositions(balloon) {\n    // Only when balloonProps[1] is 0 (the delay) will the balloons start moving.\n    if (balloon[delay] \u003c 0) {\n        var position = getLocation(balloon[distanceTravelled]);\n        // Slow down the balloon if the slowdown powerup is engaged\n        var travelSpeed = balloon[speed] * slowdownAmount;\n        // Increases the balloon\'s total steps by the speed\n        balloon[distanceTravelled] += travelSpeed;\n        // Drawing of ballon\n        ellipseMode(CENTER);\n        strokeWeight(0);\n        stroke(0);\n        fill(0);\n        // draw healthbar outline\n        stroke(0, 0, 0);\n        strokeWeight(0);\n        rectMode(CORNER);\n        fill(color(0x83, 0x00, 0x00));\n        var hbLength = 35, hbWidth = 6;\n        rect(position.x - hbLength / 2, position.y - (balloonRadius), hbLength, hbWidth);\n        // draw mini healthbar\n        noStroke();\n        fill(color(0xFF, 0x31, 0x31));\n        // the healthbar that changes based on hp\n        rect(position.x - hbLength / 2, position.y - (balloonRadius), hbLength * (balloon[hp] / balloon[maxHP]), hbWidth);\n        noFill();\n        // write text\n        stroke(0, 0, 0);\n        textSize(14);\n        fill(255, 255, 255);\n        strokeWeight(0);\n        text("Health:   " + health, 670, 462);\n        fill(color(0xf3, 0xcd, 0x64));\n        if (balloon[slowed] == 1) {\n            fill(color(0xC1, 0x9D, 0x40));\n        }\n        ellipse(position.x, position.y, balloonRadius, balloonRadius);\n    } else {\n        balloon[delay]--;\n    }\n}\n\nfunction drawBalloons() {\n    balloons = levels[levelNum];\n    for (var i = 0; i \u003c balloons.length; i++) {\n        var balloon = balloons[i];\n        updatePositions(balloon);\n        var position = getLocation(balloon[distanceTravelled]);\n        if (balloonSpikeCollision(position)) {\n            handleBalloonPop();\n            balloons.splice(i, 1);\n            i--;\n            continue;\n        }\n        if (balloon[hp] \u003c= 0) {\n            handleBalloonPop();\n            balloons.splice(i, 1);\n            i--;\n            continue;\n        }\n        if (balloon[distanceTravelled] \u003e= pathLength) {\n            // Removing the balloon from the list\n            balloons.splice(i, 1);\n            // Lost a life.\n            health--;\n            // Must decrease this counter variable, since the "next" balloon would be skipped\n            i--;\n            // When you remove a balloon from the list, all the indexes of the balloons "higher-up" in the list will decrement by 1\n        }\n    }\n    if (balloons.length == 0 \u0026\u0026 playingLevel) {\n        playingLevel = false;\n        handleWaveReward(levelNum + 1);\n    }\n}\n\n// variable to track user\'s health\nvar health;\n\nvar heart;\n\n// ------- HP SYSTEM --------\n/*\n  Heath-related variables:\n int health: The player\'s total health.\n This number decreases if balloons pass the end of the path (offscreen), currentely 11 since there are 11 balloons.\n PImage heart: the heart icon to display with the healthbar.\n */\nfunction loadHeartIcon() {\n    heart = loadImage("https://raw.githubusercontent.com/mcpt/game-dev/main/PartThree/data/heart.png");\n}\n\n// method to draw a healthbar at the bottom right of the screen\nfunction drawHealthBar() {\n    // draw healthbar outline\n    stroke(0, 0, 0);\n    strokeWeight(0);\n    fill(color(0x83, 0x00, 0x00));\n    rectMode(CENTER);\n    rect(721, 455, 132, 20);\n    var trueHealth = max(health, 0);\n    // draw healthbar\n    noStroke();\n    rectMode(CORNER);\n    fill(color(0xFF, 0x31, 0x31));\n    // the healthbar that changes based on hp\n    rect(655, 445.5, trueHealth * 12, 20);\n    rectMode(CENTER);\n    noFill();\n    // write text\n    stroke(0, 0, 0);\n    textSize(14);\n    fill(255, 255, 255);\n    text("Health:   " + trueHealth, 670, 462);\n    // put the heart.png image on screen\n    imageMode(CENTER);\n    image(heart, 650, 456);\n    noFill();\n}\n\n// Next level Button\nfunction pointRectCollision(x1, y1, x2, y2, sizeX, sizeY) {\n    // --X Distance--               --Y Distance--\n    return (Math.abs(x2 - x1) \u003c= sizeX / 2) \u0026\u0026 (Math.abs(y2 - y1) \u003c= sizeY / 2);\n}\n\nfunction handleNextLevel() {\n    var center = new p5.Vector(100, 400);\n    var lengths = new p5.Vector(100, 100);\n    if (!playingLevel \u0026\u0026 pointRectCollision(mouseX, mouseY, center.x, center.y, lengths.x, lengths.y) \u0026\u0026 levelNum \u003c levels.length - 1) {\n        playingLevel = true;\n        levelNum++;\n    }\n}\n\nfunction drawNextLevelButton() {\n    var center = new p5.Vector(60, 425);\n    var lengths = new p5.Vector(100, 70);\n    fill(0, 150, 0);\n    if (playingLevel) {\n        fill(0, 150, 0, 100);\n    }\n    rect(center.x, center.y, lengths.x, lengths.y, 10);\n    fill(255);\n    text("Next Level", center.x - 28, center.y + 4);\n}\n\n// Give the user $750 of starting balance\nvar currentBalance;\n\n// Money earned by popping a balloon\nvar rewardPerBalloon;\n\n// base money earned per wave\nvar baseRewardPerWave;\n\n/**\n * Currency system for tower defense\n *  - Rewards player for popping balloon\n *  - Keeps track of balance\n *  - Checks for sufficient funds when purchasing tower\n */\n// Current amount of money owned by the player\nfunction handleBalloonPop() {\n    // Reward the player for popping the balloon\n    increaseBalance(rewardPerBalloon);\n}\n\nfunction increaseBalance(amount) {\n    // Increase the current balance by the amount given\n    currentBalance += amount;\n}\n\n// method to give user money for completing a wave\nfunction handleWaveReward(waveNum) {\n    increaseBalance(baseRewardPerWave * waveNum);\n}\n\n/**\n * Checks to see if there is sufficient balance for purchasing a certain item\n *  Parameter "cost" is the cost of the tower to be purchased\n */\nfunction hasSufficientFunds(cost) {\n    if (currentBalance \u003c cost) {\n        // Not enough money to purchase the tower\n        return false;\n    } else {\n        // Enough money to purchase the tower\n        return true;\n    }\n}\n\n/**\n * Purchases a tower\n *  Parameter "cost" is the cost of the tower to be purchased\n */\nfunction purchaseTower(cost) {\n    currentBalance -= cost;\n}\n\n// Checks to see if the user is attempting to purchase/pick up a tower but has insufficient funds\nfunction attemptingToPurchaseTowerWithoutFunds(towerID) {\n    if (mouseIsPressed \u0026\u0026 withinBounds(towerID) \u0026\u0026 !hasSufficientFunds(towerPrice[towerID])) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Displays the user\'s current balance on the screen\nfunction drawBalanceDisplay() {\n    // If the user is attempting to purchase a tower without funds, warn them with red display text\n    var error = false;\n    for (var i = 0; i \u003c towerCount; i++) {\n        if (attemptingToPurchaseTowerWithoutFunds(i)) {\n            error = true;\n        }\n    }\n    if (error) {\n        fill(towerErrorColour);\n    } else {\n        // Black text\n        fill(0);\n    }\n    text("Current Balance: $" + currentBalance, 336, 65);\n}\n\n// -1 = not holding any tower, 0 = within default, 1 = within eight, 2 = within slow\nvar currentlyDragging;\n\nvar notDragging;\n\nvar def, eight, slow;\n\nvar towerCount;\n\nvar difX, difY, count, towerClicked;\n\nvar held;\n\nvar towerPrice;\n\nvar towerColours;\n\n// Constant, "copy" array to store where the towers are supposed to be\nvar originalLocations;\n\n// Where the currently dragged towers are\nvar dragAndDropLocations;\n\n// Towers that are placed down\nvar towers;\n\nvar towerSize;\n\n// Colour to display when user purchases tower without sufficient funds\nvar towerErrorColour;\n\n// these variables are the trash bin coordinates\nvar trashX1, trashY1, trashX2, trashY2;\n\n/*\nEncompasses: Displaying Towers, Drag \u0026 Drop, Discarding Towers, Rotating Towers, Tower Validity Checking\n */\n// -------- CODE FOR DRAG \u0026 DROP ----------------------\n// final color\nfunction initDragAndDrop() {\n    difX = 0;\n    difY = 0;\n    trashX1 = 525;\n    trashY1 = 30;\n    trashX2 = 775;\n    trashY2 = 120;\n    count = 0;\n    towers = [];\n    towerData = [];\n    spikeLocations = [];\n    spikeData = [];\n}\n\n// Use point to rectangle collision detection to check for mouse being within bounds of pick-up box\nfunction pointRectCollision(x1, y1, x2, y2, size) {\n    // --X Distance--               --Y Distance--\n    return (Math.abs(x2 - x1) \u003c= size / 2) \u0026\u0026 (Math.abs(y2 - y1) \u003c= size / 2);\n}\n\nfunction withinBounds(towerID) {\n    var towerLocation = dragAndDropLocations[towerID];\n    return pointRectCollision(mouseX, mouseY, towerLocation.x, towerLocation.y, towerSize);\n}\n\n// check if you drop in trash\nfunction trashDrop(towerID) {\n    var location = dragAndDropLocations[towerID];\n    if (location.x \u003e= trashX1 \u0026\u0026 location.x \u003c= trashX2 \u0026\u0026 location.y \u003e= trashY1 \u0026\u0026 location.y \u003c= trashY2)\n        return true;\n    return false;\n}\n\n// -------Methods Used for further interaction-------\nfunction handleDrop(towerID) {\n    // Instructions to check for valid drop area will go here\n    if (trashDrop(towerID)) {\n        dragAndDropLocations[towerID] = originalLocations[towerID];\n        held[towerID] = false;\n        print("Dropped object in trash.");\n    } else if (legalDrop(towerID)) {\n        towers.push(dragAndDropLocations[towerID].copy());\n        towerData.push(makeTowerData(towerID));\n        dragAndDropLocations[towerID] = originalLocations[towerID];\n        held[towerID] = false;\n        purchaseTower(towerPrice[towerID]);\n        print("Dropped for the " + (++count) + "th time.");\n    }\n}\n\n// Will be called whenever a tower is picked up\nfunction handlePickUp(pickedUpTowerID) {\n    if (withinBounds(pickedUpTowerID) \u0026\u0026 hasSufficientFunds(towerPrice[pickedUpTowerID])) {\n        currentlyDragging = pickedUpTowerID;\n        held[currentlyDragging] = true;\n        var location = dragAndDropLocations[pickedUpTowerID];\n        // Calculate the offset values (the mouse pointer may not be in the direct centre of the tower)\n        difX = parseInt(location.x) - mouseX;\n        difY = parseInt(location.y) - mouseY;\n    }\n    print("Object picked up.");\n}\n\nfunction drawTrash() {\n    rectMode(CORNERS);\n    noStroke();\n    fill(color(0x4C, 0x67, 0x10));\n    rect(trashX1, trashY1, trashX2, trashY2);\n    fill(255, 255, 255);\n    stroke(255, 255, 255);\n}\n\nfunction dragAndDropInstructions() {\n    fill(color(0x4C, 0x67, 0x10));\n    textSize(12);\n    text("Pick up tower from here!", 620, 20);\n    text("You can\'t place towers on the path of the balloons!", 200, 20);\n    text("Place a tower into the surrounding area to put it in the trash.", 200, 40);\n    text("Mouse X: " + mouseX + "\\nMouse Y: " + mouseY + "\\nMouse held: " + mouseIsPressed + "\\nTower Held: " + currentlyDragging, 15, 20);\n}\n\n// -------- CODE FOR PATH COLLISION DETECTION ---------\nfunction pointDistToLine(start, end, point) {\n    // Code from https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\n    // i.e. |w-v|^2 -  avoid a sqrt\n    var l2 = (start.x - end.x) * (start.x - end.x) + (start.y - end.y) * (start.y - end.y);\n    // v == w case\n    if (l2 == 0.0)\n        return dist(end.x, end.y, point.x, point.y);\n    var t = max(0, min(1, p5.Vector.sub(point, start).dot(p5.Vector.sub(end, start)) / l2));\n    // Projection falls on the segment\n    var projection = p5.Vector.add(start, p5.Vector.mult(p5.Vector.sub(end, start), t));\n    return dist(point.x, point.y, projection.x, projection.y);\n}\n\nfunction pointDistToArc(start, center, end, arcData, point) {\n    if (Math.abs(arcData.y) \u003c radians(360)) {\n        var towerAngles = new Array(2);\n        towerAngles[0] = atan2(point.y - center.y, point.x - center.x) - arcData.x;\n        if (towerAngles[0] \u003c 0) {\n            towerAngles[1] = towerAngles[0] + radians(360);\n        } else if (towerAngles[0] \u003e 0) {\n            towerAngles[1] = towerAngles[0] - radians(360);\n        } else {\n            towerAngles[1] = 0;\n        }\n        for (var _ in towerAngles) {\n            var t = towerAngles[_] / arcData.y;\n            if (t \u003e= 0 \u0026\u0026 t \u003c= 1) {\n                return Math.abs(dist(point.x, point.y, center.x, center.y) - arcData.z);\n            }\n        }\n    }\n    return min(dist(point.x, point.y, start.x, start.y), dist(point.x, point.y, end.x, end.y));\n}\n\nfunction shortestDist(point) {\n    var answer = Number.MAX_VALUE;\n    var distance = Number.MAX_VALUE;\n    for (var i = 0; i \u003c pathSegments.length; i++) {\n        var pathSegment = pathSegments[i];\n        if (pathSegment.length == 2) {\n            var startPoint = pathSegment[start];\n            var endPoint = pathSegment[end];\n            distance = pointDistToLine(startPoint, endPoint, point);\n        } else {\n            var centerPoint = pathSegment[centerArc];\n            var arcData = pathSegment[arcValues];\n            if (dist(point.x, point.y, centerPoint.x, centerPoint.y) \u003c arcData.z + 30) {\n                var startPoint = pathSegment[startArc];\n                var endPoint = pathSegment[endArc];\n                distance = pointDistToArc(startPoint, centerPoint, endPoint, arcData, point);\n            }\n        }\n        answer = min(answer, distance);\n    }\n    return answer;\n}\n\n// Will return if a drop is legal by looking at the shortest distance between the rectangle center and the path.\nfunction legalDrop(towerID) {\n    var heldLocation = dragAndDropLocations[towerID];\n    // checking if this tower overlaps any of the already placed towers\n    for (var i = 0; i \u003c towers.length; i++) {\n        var towerLocation = towers[i];\n        if (pointRectCollision(heldLocation.x, heldLocation.y, towerLocation.x, towerLocation.y, towerSize))\n            return false;\n    }\n    return shortestDist(heldLocation) \u003e PATH_RADIUS;\n}\n\n// Checks if the location of the spike is on the path\nfunction legalSpikeDrop() {\n    var heldLocation = spikeLocation;\n    return shortestDist(heldLocation) \u003c= PATH_RADIUS;\n}\n\nvar framesSinceLost;\n\nfunction drawLostAnimation() {\n    framesSinceLost++;\n    var alpha = 166 * framesSinceLost / 80;\n    if (alpha \u003e 166)\n        alpha = 166;\n    fill(127, alpha);\n    rectMode(CORNER);\n    noStroke();\n    rect(0, 0, 800, 500);\n    var textAlpha = 255 * (framesSinceLost - 80) / 80;\n    if (textAlpha \u003e 255)\n        ;\n    textAlpha = 255;\n    fill(255, textAlpha);\n    textSize(70);\n    text("YOU LOST...", 265, 260);\n}\n\n// ------- CODE FOR THE PATH\nvar pathSegments;\n\nvar start, end;\n\nvar startArc, centerArc, endArc, arcValues;\n\nvar PATH_RADIUS;\n\nvar pathLength;\n\n/*\nEncompasses: The Path for Balloons, Balloon Movement\n */\nfunction initPoints() {\n    addLine(0, 100, 300, 100);\n    addSmoothArc(50, PI);\n    addSmoothLine(70);\n    addSmoothArc(-50, -PI);\n    addSmoothLine(100);\n    addSmoothArc(-50, -PI / 2);\n    addSmoothArc(75, PI / 3);\n    addSmoothArc(125, PI / 2);\n    addSmoothLine(40);\n    addSmoothArc(100, PI / 2);\n}\n\nfunction addLine(startX, startY, endX, endY) {\n    pathSegments.push([]);\n    // If the line should continue from the existing path\n    if (startX === -1 \u0026\u0026 startY === -1) {\n        var pathSegment = pathSegments[pathSegments.length - 2];\n        // If the previous path segment was a line\n        if (pathSegment.length === 2) {\n            startX = pathSegment[end].x;\n            startY = pathSegment[end].y;\n        } else // If the previous path segment was an arc\n        {\n            startX = pathSegment[endArc].x;\n            startY = pathSegment[endArc].y;\n        }\n    }\n    pathSegments[pathSegments.length - 1].push(new p5.Vector(startX, startY));\n    pathSegments[pathSegments.length - 1].push(new p5.Vector(endX, endY));\n}\n\nfunction addArc(x, y, centerX, centerY, displacementAngle) {\n    pathSegments.push([]);\n    // If the line should continue from the existing path\n    if (x == -1 \u0026\u0026 y == -1) {\n        var pathSegment = pathSegments[pathSegments.length - 2];\n        // If the previous path segment was a line\n        if (pathSegment.length == 2) {\n            x = pathSegment[end].x;\n            y = pathSegment[end].y;\n        } else // If the previous path segment was an arc\n        {\n            x = pathSegment[endArc].x;\n            y = pathSegment[endArc].y;\n        }\n    }\n    // Starting angle\n    var startingAngle = atan2(y - centerY, x - centerX);\n    // radius of the arc\n    var radius = dist(x, y, centerX, centerY);\n    // Angle that will determine where the end coordinates are for the arc\n    var finalAngle = startingAngle + displacementAngle;\n    pathSegments[pathSegments.length - 1].push(new p5.Vector(x, y));\n    pathSegments[pathSegments.length - 1].push(new p5.Vector(centerX, centerY));\n    pathSegments[pathSegments.length - 1].push(new p5.Vector(centerX + radius * Math.cos(finalAngle), centerY + radius * Math.sin(finalAngle)));\n    pathSegments[pathSegments.length - 1].push(new p5.Vector(startingAngle, displacementAngle, radius));\n}\n\nfunction addSmoothArc(distanceAway, displacementAngle) {\n    var endPoint;\n    var directionVector;\n    var pathSegment = pathSegments[pathSegments.length - 1];\n    if (pathSegment.length == 2) {\n        var startPoint = pathSegment[start];\n        endPoint = pathSegment[end];\n        var scaleFactor = dist(startPoint.x, startPoint.y, endPoint.x, endPoint.y);\n        directionVector = new p5.Vector(-(endPoint.y - startPoint.y) * distanceAway / scaleFactor, (endPoint.x - startPoint.x) * distanceAway / scaleFactor);\n    } else {\n        var centerPoint = pathSegment[centerArc];\n        endPoint = pathSegment[endArc];\n        var scaleFactor = dist(centerPoint.x, centerPoint.y, endPoint.x, endPoint.y) * pathSegment[arcValues].y / Math.abs(pathSegment[arcValues].y);\n        directionVector = new p5.Vector((centerPoint.x - endPoint.x) * distanceAway / scaleFactor, (centerPoint.y - endPoint.y) * distanceAway / scaleFactor);\n    }\n    addArc(-1, -1, endPoint.x + directionVector.x, endPoint.y + directionVector.y, displacementAngle);\n}\n\nfunction addSmoothLine(steps) {\n    var pathSegment = pathSegments[pathSegments.length - 1];\n    var centerPoint = pathSegment[centerArc];\n    var endPoint = pathSegment[endArc];\n    var scaleFactor = dist(centerPoint.x, centerPoint.y, endPoint.x, endPoint.y) * pathSegment[arcValues].y / Math.abs(pathSegment[arcValues].y);\n    var directionVector = new p5.Vector(-(endPoint.y - centerPoint.y) / scaleFactor, (endPoint.x - centerPoint.x) / scaleFactor);\n    directionVector = p5.Vector.mult(directionVector, steps);\n    addLine(-1, -1, endPoint.x + directionVector.x, endPoint.y + directionVector.y);\n}\n\nfunction initPath() {\n    print("iyadfuisadyfgyuasdgf")\n    initPoints();\n    for (var i = 0; i \u003c pathSegments.length; i++) {\n        var pathSegment = pathSegments[i];\n        print(pathSegment)\n        var point1 = pathSegment[0];\n        var point2 = pathSegment[1];\n        if (pathSegment.length === 4) {\n            pathLength += Math.abs(pathSegment[arcValues].y * pathSegment[arcValues].z);\n        } else {\n            pathLength += dist(point1.x, point1.y, point2.x, point2.y);\n        }\n    }\n}\n\nfunction drawPath() {\n    noFill();\n    stroke(color(0x4C, 0x67, 0x10));\n    strokeWeight(PATH_RADIUS * 2 + 1);\n    ellipseMode(CENTER);\n    for (var i = 0; i \u003c pathSegments.length; i++) {\n        var pathSegment = pathSegments[i];\n        var point2 = pathSegment[end];\n        if (pathSegment.length == 2) {\n            var point1 = pathSegment[start];\n            line(point1.x, point1.y, point2.x, point2.y);\n        } else {\n            var arcData = pathSegment[arcValues];\n            var angle1;\n            var angle2;\n            if (arcData.y \u003c= 0) {\n                angle1 = arcData.x + arcData.y;\n                angle2 = arcData.x;\n            } else {\n                angle2 = arcData.x + arcData.y;\n                angle1 = arcData.x;\n            }\n            arc(point2.x, point2.y, arcData.z * 2, arcData.z * 2, angle1, angle2);\n        }\n    }\n    stroke(color(0x7b, 0x9d, 0x32));\n    strokeWeight(PATH_RADIUS * 2);\n    for (var i = 0; i \u003c pathSegments.length; i++) {\n        var pathSegment = pathSegments[i];\n        var point2 = pathSegment[end];\n        if (pathSegment.length == 2) {\n            var point1 = pathSegment[start];\n            line(point1.x, point1.y, point2.x, point2.y);\n        } else {\n            var arcData = pathSegment[arcValues];\n            var angle1;\n            var angle2;\n            if (arcData.y \u003c= 0) {\n                angle1 = arcData.x + arcData.y;\n                angle2 = arcData.x;\n            } else {\n                angle2 = arcData.x + arcData.y;\n                angle1 = arcData.x;\n            }\n            arc(point2.x, point2.y, arcData.z * 2, arcData.z * 2, angle1, angle2);\n        }\n    }\n}\n\nvar dp;\n\n// GIVEN TO PARTICIPANTS BY DEFAULT\nfunction getLocation(travelDistance) {\n    var memoized = dp[travelDistance]\n    if (memoized !== undefined) {\n        return memoized;\n    }\n    var originalDist = travelDistance;\n    var distance;\n    var point1;\n    var point2;\n    for (var i = 0; i \u003c pathSegments.length; i++) {\n        var pathSegment = pathSegments[i];\n        point1 = pathSegment[0];\n        point2 = pathSegment[1];\n        distance = dist(point1.x, point1.y, point2.x, point2.y);\n        if (pathSegment.length == 4) {\n            distance = Math.abs(pathSegment[arcValues].y * pathSegment[arcValues].z);\n        }\n        if (distance \u003c= 0.0000001 || travelDistance \u003e= distance) {\n            travelDistance -= distance;\n        } else {\n            // In between two pathSegments\n            var x;\n            var y;\n            if (pathSegment.length == 2) {\n                var xDist = point2.x - point1.x;\n                var yDist = point2.y - point1.y;\n                var travelProgress = travelDistance / distance;\n                x = point1.x + xDist * travelProgress;\n                y = point1.y + yDist * travelProgress;\n            } else {\n                var arcData = pathSegment[arcValues];\n                // initial angle  //radius\n                var angle = arcData.x + ((1 / arcData.z) * travelDistance * arcData.y / Math.abs(arcData.y));\n                x = point2.x + arcData.z * Math.cos(angle);\n                y = point2.y + arcData.z * Math.sin(angle);\n            }\n            dp[originalDist] = new p5.Vector(x, y);\n            return new p5.Vector(x, y);\n        }\n    }\n    // At end of path\n    var lastPathSegment = pathSegments[pathSegments.length - 1];\n    if (lastPathSegment.length == 2) {\n        dp[originalDist] = lastPathSegment[end];\n        return lastPathSegment[end];\n    } else {\n        dp[originalDist] = lastPathSegment[endArc];\n        return lastPathSegment[endArc];\n    }\n}\n\n// Amount of each powerup remaining\nvar powerupCount;\n\nvar spikes, slowdown, speedboost;\n\n// Amount of balloons the cluster of spikes will pop before disappearing\nvar spikePierce;\n\n// Amount of time that a slowdown session lasts for in seconds\nvar slowdownLength;\n\n// Amount of time that a speed boost session lasts for in seconds\nvar speedBoostLength;\n\n// The factor to multiply all balloon speeds by\nvar slowdownAmount;\n\nvar slowdownRemaining;\n\nvar slowdownLocation;\n\n// Factor to multiply all tower cooldowns by\nvar speedBoostAmount;\n\nvar speedBoostRemaining;\n\nvar speedBoostLocation;\n\n// Image for path spikes\nvar spikeIcon;\n\n// Location of spike for drag and drop\nvar spikeLocation;\n\nvar spikeLocations;\n\nvar spikeData;\n\nvar originalSpikeLocation;\n\nvar spikeHeld;\n\n/**\n * All powerups including\n *  - Path spikes\n *  - Slow Time\n *  - Damage/Speed boost for towers\n */\n/**\n * Reimplementation of Drag and Drop for path spikes *\n */\nfunction withinSpikeBounds() {\n    return pointRectCollision(mouseX, mouseY, spikeLocation.x, spikeLocation.y, 45);\n}\n\nfunction spikeTrashDrop() {\n    var location = spikeLocation;\n    if (location.x \u003e= trashX1 \u0026\u0026 location.x \u003c= trashX2 \u0026\u0026 location.y \u003e= trashY1 \u0026\u0026 location.y \u003c= trashY2)\n        return true;\n    return false;\n}\n\nfunction handleSpikePickUp() {\n    if (withinSpikeBounds() \u0026\u0026 powerupCount[spikes] \u003e 0) {\n        spikeHeld = true;\n        var location = spikeLocation;\n        // Calculate the offset values (the mouse pointer may not be in the direct centre of the tower)\n        difX = parseInt(location.x) - mouseX;\n        difY = parseInt(location.y) - mouseY;\n    }\n}\n\nfunction handleSpikeDrop() {\n    if (spikeTrashDrop()) {\n        spikeLocation = originalSpikeLocation;\n        print("Spike object in trash.");\n    } else if (legalSpikeDrop()) {\n        // Decrease remaining spikes by 1\n        powerupCount[spikes]--;\n        spikeLocations.push(spikeLocation.copy());\n        spikeData.push(spikePierce);\n        spikeLocation = originalSpikeLocation;\n        print("Spike Dropped on Path");\n    }\n    spikeHeld = false;\n}\n\nfunction loadSpikeIcon() {\n    spikeIcon = loadImage("https://raw.githubusercontent.com/mcpt/game-dev/main/PartThree/data/spikes.png");\n}\n\nfunction drawSpikeIcon(location, colour) {\n    ellipseMode(RADIUS);\n    fill(colour);\n    ellipse(location.x, location.y, 20, 20);\n    imageMode(CENTER);\n    image(spikeIcon, location.x, location.y);\n}\n\nfunction drawSpikeIcon(location) {\n    imageMode(CENTER);\n    image(spikeIcon, location.x, location.y);\n}\n\nfunction drawAllSpikes() {\n    for (var i = 0; i \u003c spikeLocations.length; i++) {\n        if (spikeData[i] \u003c= 0) {\n            spikeData.splice(i, 1);\n            spikeLocations.splice(i, 1);\n            i--;\n        } else {\n            drawSpikeIcon(spikeLocations[i]);\n        }\n    }\n}\n\nfunction drawCurrentSpikeIcon() {\n    if (legalSpikeDrop() || spikeLocation == originalSpikeLocation) {\n        drawSpikeIcon(spikeLocation, color(0xFF, 0xFF, 0xFF));\n    } else {\n        drawSpikeIcon(spikeLocation, color(0xF0, 0x00, 0x00));\n    }\n}\n\nfunction balloonSpikeCollision(position) {\n    for (var i = 0; i \u003c spikeLocations.length; i++) {\n        var spikeLocation = spikeLocations[i];\n        if (dist(position.x, position.y, spikeLocation.x, spikeLocation.y) \u003c= PATH_RADIUS) {\n            spikeData[i] = spikeData[i] - 1;\n            // // Spike has popped the balloon!\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction displayPowerups() {\n    fill(255);\n    text("Slowdowns remaining: " + powerupCount[slowdown], 655, 184);\n    text("Speed Boosts remaining: " + powerupCount[speedboost], 635, 234);\n    var displayColour;\n    /**\n     * Slowdown\n     */\n    if (mouseIsPressed \u0026\u0026 withinSlowdownBounds() \u0026\u0026 powerupCount[slowdown] \u003c= 0 \u0026\u0026 slowdownRemaining \u003c= 0) {\n        // Display using red error colour\n        displayColour = color(0xF0, 0x00, 0x00);\n    } else if (slowdownRemaining \u003e 0) {\n        // Display blue colour for slowdown in progress\n        displayColour = color(0x81, 0xE5, 0xFF);\n    } else {\n        // Display using white colour\n        displayColour = color(0xFF, 0xFF, 0xFF);\n    }\n    fill(displayColour);\n    ellipseMode(RADIUS);\n    ellipse(slowdownLocation.x, slowdownLocation.y, 20, 20);\n    /**\n     * Speed Boosts\n     */\n    if (mouseIsPressed \u0026\u0026 withinSpeedBoostBounds() \u0026\u0026 powerupCount[speedboost] \u003c= 0 \u0026\u0026 speedBoostRemaining \u003c= 0) {\n        // Display using red error colour\n        displayColour = color(0xF0, 0x00, 0x00);\n    } else if (speedBoostRemaining \u003e 0) {\n        // Display blue colour for slowdown in progress\n        displayColour = color(0x81, 0xE5, 0xFF);\n    } else {\n        // Display using white colour\n        displayColour = color(0xFF, 0xFF, 0xFF);\n    }\n    fill(displayColour);\n    ellipse(speedBoostLocation.x, speedBoostLocation.y, 20, 20);\n    /**\n     * Spikes\n     */\n    if (mouseIsPressed \u0026\u0026 withinSpikeBounds() \u0026\u0026 powerupCount[spikes] \u003c= 0) {\n        // Display using red error colour\n        displayColour = color(0xF0, 0x00, 0x00);\n    } else {\n        // Display using white colour\n        displayColour = color(0xFF, 0xFF, 0xFF);\n    }\n    fill(displayColour);\n    text("Spikes remaining: " + powerupCount[spikes], 625, 146);\n    drawSpikeIcon(originalSpikeLocation, displayColour);\n}\n\nfunction withinSlowdownBounds() {\n    return pointRectCollision(mouseX, mouseY, slowdownLocation.x, slowdownLocation.y, 45);\n}\n\nfunction handleSlowdownPress() {\n    if (withinSlowdownBounds() \u0026\u0026 powerupCount[slowdown] \u003e 0 \u0026\u0026 slowdownAmount == 1) {\n        powerupCount[slowdown]--;\n        slowdownAmount = 0.5;\n        slowdownRemaining = slowdownLength * 60;\n    }\n}\n\nfunction handleSlowdown() {\n    if (slowdownRemaining \u003e 0) {\n        slowdownRemaining--;\n        if (slowdownRemaining == 0) {\n            // Revert to original speed\n            slowdownAmount = 1;\n        }\n    }\n}\n\n/**\n * Speed Boost Powerup\n */\nfunction withinSpeedBoostBounds() {\n    return pointRectCollision(mouseX, mouseY, speedBoostLocation.x, speedBoostLocation.y, 45);\n}\n\nfunction handleSpeedBoostPress() {\n    if (withinSpeedBoostBounds() \u0026\u0026 powerupCount[speedboost] \u003e 0 \u0026\u0026 speedBoostAmount == 1) {\n        powerupCount[speedboost]--;\n        speedBoostAmount = 0.4;\n        speedBoostRemaining = speedBoostLength * 60;\n    }\n}\n\nfunction handleSpeedBoost() {\n    if (speedBoostRemaining \u003e 0) {\n        speedBoostRemaining--;\n        if (speedBoostRemaining == 0) {\n            // Revert to original speed\n            speedBoostAmount = 1;\n        }\n    }\n}\n\n// Stores the location of each projectile and how fast it should move each frame\nvar center, velocity;\n\n// Stores additional projectile data (unrelated to motion)\nvar projectileData;\n\n// Stores a list of balloons that each projectile has hit, so it doesn\'t hit the same balloon twice\nvar balloonsHit;\n\n// Constants to make accessing the projectileData array more convenient\nvar damage, pierce, angle, currDistTravelled, maxDistTravelled, thickness, dmgType;\n\nvar projectileRadius;\n\n// changed values to help upgrades\nvar defdmg, eightdmg, slowdmg;\n\nvar shots;\n\nvar slowPercent;\n\n// -------------- TEMPLATE CODE BEGINS ---------------- (Participants will NOT need to code anything below this line)\n// For Participants: The HashSet data structure is like an ArrayList, but can tell you whether it contains a value or not very quickly\n// The downside of HashSets is that there is no order or indexes, so you can\'t use it like a normal list\n// Think of it like throwing items into an unorganized bin\n// Adds a new projectile\nfunction createProjectile(centre, vel, damage, pierce, maxDistTravelled, thickness, dmgType) {\n    // Adds an empty set to the balloonsHit structure - this represents the current projectile, not having hit any balloons yet.\n    balloonsHit.push([]);\n    // Adds the starting location of the projectile as the current location\n    center.push(centre);\n    // Adds the velocity of the projectile to the list\n    velocity.push(vel);\n    var angle = atan2(vel.y, vel.x);\n    projectileData.push( [ damage, pierce, angle, 0, maxDistTravelled, thickness, dmgType ]);\n}\n\n// Checks the distance from a point to a projectile using the pointDistToLine() method coded earlier\nfunction distToProjectile(projectileID, point) {\n    var data = projectileData[projectileID];\n    var width = Math.cos(data[angle]), height = Math.sin(data[angle]);\n    var displacement = new p5.Vector(width, height).mult(projectileRadius);\n    var start = p5.Vector.add(center[projectileID], displacement), end = p5.Vector.sub(center[projectileID], displacement);\n    return pointDistToLine(start, end, point);\n}\n\n// Checks if a projectile is ready to be removed (is it off screen? has it already reached its maximum pierce? has it exceeded the maximum distance it needs to travel?)\nfunction dead(projectileID) {\n    var data = projectileData[projectileID];\n    return offScreen(projectileID) || data[pierce] == 0 || data[currDistTravelled] \u003e data[maxDistTravelled];\n}\n\n// Checks if a projectile is off-screen\nfunction offScreen(projectileID) {\n    return center[projectileID].x \u003c 0 || center[projectileID].x \u003e 800 || center[projectileID].y \u003c 0 || center[projectileID].y \u003e 500;\n}\n\n// Displays a projectile and handles movement \u0026 collision via their respective methods\nfunction drawProjectile(projectileID) {\n    var data = projectileData[projectileID];\n    stroke(255);\n    strokeWeight(data[thickness]);\n    var width = Math.cos(data[angle]), height = Math.sin(data[angle]);\n    var displacement = new p5.Vector(width, height).mult(projectileRadius);\n    var start = p5.Vector.add(center[projectileID], displacement), end = p5.Vector.sub(center[projectileID], displacement);\n    line(start.x, start.y, end.x, end.y);\n    handleProjectileMovement(projectileID);\n    handleCollision(projectileID);\n}\n\n// Updates projectile locations\nfunction handleProjectileMovement(projectileID) {\n    // Adds the velocity to the current position\n    var nextLocation = p5.Vector.add(center[projectileID], velocity[projectileID]);\n    // Updates the current position\n    center[projectileID] = nextLocation;\n    var data = projectileData[projectileID];\n    // Tracks the current distance travelled, so that if it exceeds the maximum projectile range, it disappears\n    data[currDistTravelled] += velocity[projectileID].mag();\n}\n\n// Checks collision with balloons\nfunction handleCollision(projectileID) {\n    var data = projectileData[projectileID];\n    for (var b in balloons) {\n        var balloon = balloons[b];\n        // If the balloon hasn\'t entered yet, don\'t count it\n        if (balloon[delay] \u003e 0)\n            continue;\n        var position = getLocation(balloon[distanceTravelled]);\n        if (distToProjectile(projectileID, position) \u003c= balloonRadius / 2 + data[thickness] / 2) {\n            // Already hit the balloon / already used up its max pierce\n            if (data[pierce] === 0 || balloonsHit[projectileID].includes(parseInt(balloon[ID])))\n                continue;\n            // Lowers the pierce by 1 after hitting the balloon\n            data[pierce]--;\n            // Adds the projectile to the set of already hit balloons\n            balloonsHit[projectileID].push(parseInt(balloon[ID]));\n            hitBalloon(projectileID, balloon);\n        }\n    }\n}\n\n// -------------- TEMPLATE CODE ENDS ---------------- (Participants will NOT need to code anything above this line)\n// Code that is called when a projectile hits a balloon\nfunction hitBalloon(projectileID, balloonData) {\n    var data = projectileData[projectileID];\n    // Deals damage\n    balloonData[hp] -= data[damage];\n    if (data[dmgType] == slow \u0026\u0026 balloonData[slowed] == 0) {\n        // Slows down the balloon\n        var slowNum = slowPercent;\n        if (data[upgrade] \u003e= 2) {\n            slowNum -= 0.2;\n        }\n        balloonData[speed] *= slowNum;\n        balloonData[slowed] = 1;\n    }\n}\n\n// Tracks the tower that is closest to the end, within the vision of the tower\nfunction track(towerLocation, vision) {\n    var maxDist = 0;\n    var location = undefined;\n    for (var b in levels[levelNum]) {\n        var balloon = levels[levelNum][b];\n        var balloonLocation = getLocation(balloon[distanceTravelled]);\n        // Checks if the tower can see the balloon\n        if (dist(balloonLocation.x, balloonLocation.y, towerLocation.x, towerLocation.y) \u003c= vision) {\n            // If the balloon has travelled further than the previously stored one, it is now the new fastest\n            if (balloon[distanceTravelled] \u003e maxDist) {\n                location = balloonLocation;\n                maxDist = balloon[distanceTravelled];\n            }\n        }\n    }\n    return location;\n}\n\n// Handles all projectile creation\nfunction handleProjectiles() {\n    if (playingLevel) {\n        for (var i = 0; i \u003c towers.length; i++) {\n            var location = towers[i];\n            var data = towerData[i];\n            data[cooldownRemaining]--;\n            var balloon = track(location, data[towerVision]);\n            // Cooldown is 0 and there is a balloon that the tower tracks shoots a projectile\n            if (data[cooldownRemaining] \u003c= 0 \u0026\u0026 balloon !== undefined) {\n                // Resets the cooldown\n                data[cooldownRemaining] = parseInt((data[maxCooldown] * speedBoostAmount));\n                var toMouse = new p5.Vector(balloon.x - location.x, balloon.y - location.y);\n                if (data[projectileType] == def) {\n                    var speed = 24, damage = defdmg, pierce = 1, thickness = 2, maxTravelDist = 500;\n                    if (data[upgrade] \u003e= 3) {\n                        damage = defdmg + data[upgrade] - 2;\n                    }\n                    var unitVector = p5.Vector.div(toMouse, toMouse.mag());\n                    var velocity_ = p5.Vector.mult(unitVector, speed);\n                    createProjectile(location, velocity_, damage, pierce, maxTravelDist, thickness, def);\n                    // Default type\n                } else if (data[projectileType] == eight) {\n                    // Spread in 8\n                    var curShots = shots;\n                    if (data[upgrade] \u003e= 3) {\n                        curShots = shots + 8;\n                    }\n                    for (var j = 0; j \u003c curShots; j++) {\n                        var speed = 18, damage = eightdmg, pierce = 2, thickness = 2, maxTravelDist = 150;\n                        var angle = (PI * 2) * j / curShots;\n                        var unitVector = p5.Vector.div(toMouse, toMouse.mag());\n                        if (data[upgrade] \u003e= 4) {\n                            damage = eightdmg + data[upgrade] - 3;\n                        }\n                        var velocity_ = p5.Vector.mult(unitVector, speed).rotate(angle);\n                        createProjectile(location, velocity_, damage, pierce, maxTravelDist, thickness, eight);\n                    }\n                } else if (data[projectileType] == slow) {\n                    // glue gunner - slows balloons\n                    // slow-ish speed, low damage, high pierce, low range\n                    var speed = 15, damage = slowdmg, pierce = 7, thickness = 4, maxTravelDist = 220;\n                    var unitVector = p5.Vector.div(toMouse, toMouse.mag());\n                    var velocity_ = p5.Vector.mult(unitVector, speed);\n                    createProjectile(location, velocity_, damage, pierce, maxTravelDist, thickness, slow);\n                }\n            }\n        }\n    }\n    // Displays projectiles and removes those which need to be removed\n    for (var projectileID = 0; projectileID \u003c projectileData.length; projectileID++) {\n        drawProjectile(projectileID);\n        if (dead(projectileID)) {\n            projectileData.splice(projectileID, 1);\n            center.splice(projectileID, 1);\n            velocity.splice(projectileID, 1);\n            balloonsHit.splice(projectileID, 1);\n            projectileID--;\n        }\n    }\n}\n\nvar removeLocation;\n\nfunction drawRemove() {\n    strokeWeight(1);\n    stroke(color(0xde, 0xac, 0x9e));\n    fill(color(0xFF, 0x69, 0x61));\n    rectMode(CENTER);\n    rect(removeLocation.x, removeLocation.y, 70, 24, 5);\n    textSize(16);\n    fill(color(0xff, 0xff, 0xff));\n    text("Remove", removeLocation.x - 30, removeLocation.y + 4);\n}\n\nfunction removeCheck() {\n    if ((removeLocation.x - 35 \u003c= mouseX \u0026\u0026 mouseX \u003c= removeLocation.x + 35 \u0026\u0026 removeLocation.y - 12 \u003c= mouseY \u0026\u0026 mouseY \u003c= removeLocation.y + 12) \u0026\u0026 mouseIsPressed \u0026\u0026 towerClicked != -1) {\n        var temp = towerData[towerClicked];\n        currentBalance += temp[upgrade] * towerPrice[temp[projectileType]] / 2;\n        var temp1 = towerClicked;\n        towerClicked = -1;\n        towerData.splice(temp1, 1);\n        towers.splice(temp1, 1);\n    }\n}\n\nvar cooldownRemaining, maxCooldown, towerVision, projectileType, upgrade;\n\nvar towerData;\n\nvar towerVisions;\n\n/*\nEncompasses: Displaying Towers \u0026 Tower Data (for projectiles)\n*/\nfunction makeTowerData(towerID) {\n    if (towerID == def) {\n        return  [ // Cooldown between next projectile\n            10, // Max cooldown\n                10, // Tower Vision\n                towerVisions[def], // Projectile ID\n                0, 1 ];\n    } else if (towerID == eight) {\n        return  [ // Cooldown between next projectile\n            25, // Max cooldown\n                25, // Tower Vision\n                towerVisions[eight], // Projectile ID\n                1, 1 ];\n    } else if (towerID == slow) {\n        return  [ 35, 35, // Tower Vision\n            towerVisions[slow], 2, 1 ];\n    }\n    // filler since we need to return something\n    return  [];\n}\n\n// --------------------------------------------------\n// Draw a simple tower at a specified location\nfunction drawTowerIcon(xPos, yPos, colour) {\n    strokeWeight(0);\n    stroke(0);\n    fill(colour);\n    rectMode(CENTER);\n    // Draw a simple rectangle as the tower\n    rect(xPos, yPos, towerSize, towerSize);\n}\n\n// Draws a tower that rotates to face the targetLocation\nfunction drawTowerWithRotation(xPos, yPos, colour, targetLocation) {\n    push();\n    translate(xPos, yPos);\n    // Angle calculation\n    var slope = (targetLocation.y - yPos) / (targetLocation.x - xPos);\n    var angle = atan(slope);\n    rotate(angle);\n    strokeWeight(0);\n    fill(colour);\n    rectMode(CENTER);\n    // Draw a simple rectangle as the tower\n    rect(0, 0, towerSize, towerSize);\n    pop();\n}\n\nfunction drawAllTowers() {\n    for (var i = 0; i \u003c towers.length; i++) {\n        var xPos = towers[i].x, yPos = towers[i].y;\n        var data = towerData[i];\n        var towerType = data[projectileType];\n        var track_ = undefined;\n        if (playingLevel) {\n            track_ = track(towers[i], data[towerVision]);\n        }\n        if (track_ === undefined) {\n            drawTowerIcon(xPos, yPos, towerColours[towerType]);\n        } else {\n            drawTowerWithRotation(xPos, yPos, towerColours[towerType], new p5.Vector(track_.x, track_.y));\n        }\n        if (pointRectCollision(mouseX, mouseY, xPos, yPos, towerSize)) {\n            // Drawing the tower range visually\n            fill(127, 80);\n            stroke(127);\n            strokeWeight(4);\n            ellipseMode(RADIUS);\n            ellipse(xPos, yPos, data[towerVision], data[towerVision]);\n        }\n        fill(color(0x4C, 0x67, 0x10));\n        textSize(12);\n        strokeWeight(0);\n        text("Tower " + (i + 1), xPos - 30, yPos - 20);\n    }\n}\n\nfunction drawSelectedTowers() {\n    // Note that more than one tower can be dragged at a time\n    for (var towerID = 0; towerID \u003c towerCount; towerID++) {\n        if (held[towerID]) {\n            var location = dragAndDropLocations[towerID];\n            if (!legalDrop(towerID)) {\n                drawTowerIcon(location.x, location.y, color(0xFF, 0x00, 0x00));\n            } else {\n                drawTowerIcon(location.x, location.y, towerColours[towerID]);\n            }\n            // Drawing the tower range of the selected towers\n            fill(127, 80);\n            stroke(127);\n            strokeWeight(4);\n            ellipseMode(RADIUS);\n            ellipse(location.x, location.y, towerVisions[towerID], towerVisions[towerID]);\n        }\n    }\n    // Draws the default towers\n    for (var towerType = 0; towerType \u003c towerCount; towerType++) {\n        var location = originalLocations[towerType];\n        if (attemptingToPurchaseTowerWithoutFunds(towerType)) {\n            drawTowerIcon(location.x, location.y, towerErrorColour);\n        } else\n            drawTowerIcon(location.x, location.y, towerColours[towerType]);\n        fill(255);\n        textSize(14);\n        var textOffsetX = -15, textOffsetY = 26;\n        // displays the prices of towers\n        text("$" + towerPrice[towerType], location.x + textOffsetX, location.y + textOffsetY);\n    }\n}\n\n// To upgrade towers, click them and their radius will show around them. Click the upgrade button to upgrade the tpower to the next level\nvar upgradeLocation;\n\nfunction towerClickCheck() {\n    if (mouseIsPressed) {\n        towerClicked = -1;\n    }\n    for (var i = 0; i \u003c towers.length; i++) {\n        var xPos = towers[i].x, yPos = towers[i].y;\n        if (pointRectCollision(mouseX, mouseY, xPos, yPos, towerSize) \u0026\u0026 mouseIsPressed) {\n            // Drawing the tower range visually\n            towerClicked = i;\n        }\n    }\n}\n\nfunction drawRange() {\n    if (towerClicked != -1) {\n        var xPos = towers[towerClicked].x, yPos = towers[towerClicked].y;\n        var data = towerData[towerClicked];\n        fill(127, 80);\n        stroke(127);\n        strokeWeight(4);\n        ellipseMode(RADIUS);\n        ellipse(xPos, yPos, data[towerVision], data[towerVision]);\n    }\n}\n\n// method to get damage numbers from the type of tower\'s projectile\nfunction dmgFromProjectileType(type, temp) {\n    if (type == 0) {\n        var ret = defdmg;\n        if (temp[upgrade] \u003e= 3) {\n            ret += temp[upgrade] - 2;\n        }\n        return ret;\n    } else if (type == 1) {\n        var ret = eightdmg;\n        if (temp[upgrade] \u003e= 4) {\n            ret += temp[upgrade] - 3;\n        }\n        return ret;\n    } else if (type == 2) {\n        return slowdmg;\n    }\n    return 0;\n}\n\n// draw the tower UI - includes the remove option\nfunction drawTowerUI() {\n    if (towerClicked != -1) {\n        // draw outer box for upgrades\n        var temp = towerData[towerClicked];\n        stroke(color(0xad, 0xd5, 0x58));\n        strokeWeight(1);\n        fill(color(0xE7, 0xEA, 0xB5));\n        rect(200, 450, 216, 80, 3);\n        fill(color(0x44, 0x49, 0x41));\n        strokeWeight(0);\n        text("Current Level: " + temp[upgrade], 98, 426);\n        text("range: " + temp[towerVision], 104, 446);\n        text("damage: " + (dmgFromProjectileType(temp[projectileType], temp)), 204, 446);\n        strokeWeight(2);\n        stroke(color(0xa8, 0xa8, 0x9d, 200));\n        line(100, 453, 295, 453);\n        drawUpgrade();\n        upgradeCheck();\n        drawRemove();\n        removeCheck();\n    }\n}\n\n// EDIT THIS FOR UI FOR UPGRADES\nfunction drawUpgrade() {\n    strokeWeight(0);\n    stroke(0);\n    fill(color(0xC3, 0x64, 0xFF));\n    rectMode(CENTER);\n    rect(upgradeLocation.x, upgradeLocation.y, 86, 24, 5);\n    textSize(16);\n    fill(255);\n    var temp = towerData[towerClicked];\n    strokeWeight(0);\n    text("Buy: $" + towerPrice[temp[projectileType]] / 2, upgradeLocation.x - 40, upgradeLocation.y + 4);\n}\n\nfunction upgradeCheck() {\n    if ((upgradeLocation.x - 43 \u003c= mouseX \u0026\u0026 mouseX \u003c= upgradeLocation.x + 43 \u0026\u0026 upgradeLocation.y - 12 \u003c= mouseY \u0026\u0026 mouseY \u003c= upgradeLocation.y + 12) \u0026\u0026 mouseIsPressed \u0026\u0026 towerClicked != -1) {\n        var temp = towerData[towerClicked];\n        if (currentBalance \u003e= towerPrice[temp[projectileType]] / 2) {\n            temp[upgrade]++;\n            currentBalance -= towerPrice[temp[projectileType]] / 2;\n            if (temp[projectileType] == 0) {\n                if (temp[upgrade] == 2) {\n                    // first upgrade\n                    // increases attack speed\n                    temp[maxCooldown] = 8;\n                }\n            } else if (temp[projectileType] == 1) {\n                if (temp[upgrade] == 2) {\n                    // second upgrade\n                    temp[towerVision] += 50;\n                }\n            } else if (temp[projectileType] == 2) {\n                if (temp[upgrade] \u003e 2) {\n                    temp[towerVision] += 50;\n                }\n            }\n            towerData[towerClicked] = temp;\n            print("tower number: " + (towerClicked + 1) + ", upgrade level: " + temp[upgrade]);\n        }\n    }\n}\n\nfunction initializeFields() {\n    levels = [];\n    balloons = null;\n    distanceTravelled = 0;\n    delay = 1;\n    speed = 2;\n    maxHP = 3;\n    hp = 4;\n    slowed = 5;\n    ID = 6;\n    balloonRadius = 25;\n    levelNum = -1;\n    playingLevel = false;\n    health = 11;\n    currentBalance = 100000;\n    rewardPerBalloon = 15;\n    baseRewardPerWave = 10;\n    currentlyDragging = -1;\n    notDragging = -1;\n    def = 0;\n    eight = 1;\n    slow = 2;\n    towerCount = 3;\n    difX = 0;\n    difY = 0;\n    count = 0;\n    towerClicked = -1;\n    held = [ false, false, false ];\n    towerPrice = [ 100, 200, 200 ];\n    towerColours = [ color(0x7b, 0x9d, 0x32), color(0xF0, 0x98, 0xD7), color(0x82, 0xE5, 0xF7) ];\n    originalLocations = [ new p5.Vector(650, 50), new p5.Vector(700, 50), new p5.Vector(750, 50) ];\n    dragAndDropLocations = [ new p5.Vector(650, 50), new p5.Vector(700, 50), new p5.Vector(750, 50) ];\n    towers = null;\n    towerSize = 25;\n    towerErrorColour = color(0xE3, 0x07, 0x07);\n    trashX1 = 0;\n    trashY1 = 0;\n    trashX2 = 0;\n    trashY2 = 0;\n    framesSinceLost = 0;\n    pathSegments = []\n    start = 0;\n    end = 1;\n    startArc = 0;\n    centerArc = 1;\n    endArc = 2;\n    arcValues = 3;\n    PATH_RADIUS = 20;\n    pathLength = 0;\n    dp = [];\n    powerupCount = [ 5, 3, 3 ];\n    spikes = 0;\n    slowdown = 1;\n    speedboost = 2;\n    spikePierce = 3;\n    slowdownLength = 7;\n    speedBoostLength = 7;\n    slowdownAmount = 1;\n    slowdownRemaining = 0;\n    slowdownLocation = new p5.Vector(763, 208);\n    speedBoostAmount = 1;\n    speedBoostRemaining = 0;\n    speedBoostLocation = new p5.Vector(763, 258);\n    spikeLocation = new p5.Vector(763, 150);\n    spikeLocations = null;\n    spikeData = null;\n    originalSpikeLocation = new p5.Vector(763, 150);\n    spikeHeld = false;\n    center = [];\n    velocity = [];\n    projectileData = [];\n    balloonsHit = [];\n    damage = 0;\n    pierce = 1;\n    angle = 2;\n    currDistTravelled = 3;\n    maxDistTravelled = 4;\n    thickness = 5;\n    dmgType = 6;\n    projectileRadius = 11;\n    defdmg = 6;\n    eightdmg = 4;\n    slowdmg = 1;\n    shots = 8;\n    slowPercent = 0.7;\n    removeLocation = new p5.Vector(255, 470);\n    cooldownRemaining = 0;\n    maxCooldown = 1;\n    towerVision = 2;\n    projectileType = 3;\n    upgrade = 4;\n    towerData = null;\n    towerVisions = [ 200, 100, 100 ];\n    upgradeLocation = new p5.Vector(145, 470);\n}\n\nfunction preload() {\n    loadHeartIcon();\n    loadSpikeIcon();\n// TODO: put method calls that load from files into this method\n// I found the following calls that you should move here:\n// - on line 210: heart = loadImage("heart.png")\n// - on line 861: spikeIcon = loadImage("spikes.png")\n// (note that line numbers are from your Processing code)\n}\n\n'),typeof setup!="undefined"&&(p.setup=setup),typeof draw!="undefined"&&(p.draw=draw),typeof preload!="undefined"&&(p.preload=preload),typeof mousePressed!="undefined"&&(p.mousePressed=mousePressed),typeof mouseReleased!="undefined"&&(p.mouseReleased=mouseReleased),typeof mouseClicked!="undefined"&&(p.mouseClicked=mouseClicked),typeof mouseMoved!="undefined"&&(p.mouseMoved=mouseMoved),typeof mouseDragged!="undefined"&&(p.mouseDragged=mouseDragged),typeof mouseOver!="undefined"&&(p.mouseOver=mouseOver),typeof mouseOut!="undefined"&&(p.mouseOut=mouseOut),typeof keyPressed!="undefined"&&(p.keyPressed=keyPressed),typeof keyTyped!="undefined"&&(p.keyTyped=keyTyped),typeof keyReleased!="undefined"&&(p.keyReleased=keyReleased)},"p5js-6831749251647713367503789792-canvas")</script><div class=expand><a class=expand-label onclick='$t=$(this),$t.parent(".expand-expanded.expand-marked").length?$t.next().css("display","none"):$t.parent(".expand-marked").length?$t.next().css("display","block"):$t.next(".expand-content").slideToggle(100),$t.parent().toggleClass("expand-expanded")'><i class="fas fa-chevron-down"></i>
<i class="fas fa-chevron-right"></i>
What is a tower-defense game?</a><div class=expand-content style=display:none><div class="notices info"><div class=label>Info</div><p>A <strong>tower-defense game</strong> is a type of strategy game where players will place down &ldquo;towers&rdquo;, usually with a form of in-game currency that will defend against a set of enemies. If you fail to defeat the enemies, you will typically lose health - when you reach zero, it&rsquo;s <strong>Game Over.</strong></p><p>In <strong>Bloons Tower Defense</strong>, the towers are monkeys, and the enemies are balloons, which spawn in rounds and travel along a pre-determined path. Your goal as a player is to strategically spend your currency while placing towers in effective locations, using their special abilities to win the game!</p><p>In this workshop, we will cover the fundamental aspects of a tower-defense game, and in future workshops, we will cover special abilities and ways that you can customize your game to make it your own!</p></div></div></div><p>Everything will be made step-by-step allowing you to learn and see the progress of the game. The speed of the workshop is not set and will be altered at a moment&rsquo;s notice in order, so donâ€™t worry if you don&rsquo;t get everything immediately!</p><p>This website is interactive and holds all the content that we will be going over. Flip along and test code just as we do! This site will also be accessible at any time for you to look back and review content.</p><h3 id=additional-info>Additional Info</h3><div class=expand><a class=expand-label onclick='$t=$(this),$t.parent(".expand-expanded.expand-marked").length?$t.next().css("display","none"):$t.parent(".expand-marked").length?$t.next().css("display","block"):$t.next(".expand-content").slideToggle(100),$t.parent().toggleClass("expand-expanded")'><i class="fas fa-chevron-down"></i>
<i class="fas fa-chevron-right"></i>
What you will learn</a><div class=expand-content style=display:none><div class="notices info"><div class=label>Info</div><p>In the third part of this workshop, you will finish up the game, adding more intricate paths, as well as two finalizing features: power-ups and tower upgrades!
This includes:</p><ul><li>How to use a pre-built library to create circular and disjoint paths</li><li>How to use nested ArrayLists to create multiple waves</li><li>How to modify our code for towers and projectiles to create upgrades</li><li>How to create spikes and a new interface for custom power-ups</li></ul></div></div></div><div class=expand><a class=expand-label onclick='$t=$(this),$t.parent(".expand-expanded.expand-marked").length?$t.next().css("display","none"):$t.parent(".expand-marked").length?$t.next().css("display","block"):$t.next(".expand-content").slideToggle(100),$t.parent().toggleClass("expand-expanded")'><i class="fas fa-chevron-down"></i>
<i class="fas fa-chevron-right"></i>
What you will need</a><div class=expand-content style=display:none><div class="notices info"><div class=label>Info</div><p>You will need to download <a href=https://processing.org/download>Processing 4.0</a> from <a href=https://processing.org/download>https://processing.org/download</a>, or have Processing 3 or newer installed.</p><p>In our workshop, we will be adding code to several <strong>templates</strong>, which you can download below.</p></div><div class="attachments blue"><div class=label>All Templates</div><ul class=attachments-files><li><a href=/game-dev/part-iii/introduction.files/AllTemplates.zip>AllTemplates.zip</a> (56 KB)</li></ul></div></div></div><div class=expand><a class=expand-label onclick='$t=$(this),$t.parent(".expand-expanded.expand-marked").length?$t.next().css("display","none"):$t.parent(".expand-marked").length?$t.next().css("display","block"):$t.next(".expand-content").slideToggle(100),$t.parent().toggleClass("expand-expanded")'><i class="fas fa-chevron-down"></i>
<i class="fas fa-chevron-right"></i>
The Game Jam</a><div class=expand-content style=display:none><div class="notices tip"><div class=label>Tip</div><p>Ultimately, the Game Dev Series will build up to a week-long Game Jam during the Winter Break. During the Game Jam, you&rsquo;ll develop and create the best game you can!</p><p>There will be many prizes and awards so make sure to participate!</p><p>In addition, by participating in the Game Dev Series and completing challenges, you will earn points which will help you win awards during the Game Jam.</p><p>PS. This is the last chance to get extra points before our Winter Game Jam, so be sure to try the challenges!</p></div></div></div><footer class=footline></footer></main></div><div id=navigation><a class="nav nav-prev" href=/game-dev/part-iii/ title="Part III"><i class="fa fa-chevron-left"></i></a>
<a class="nav nav-next" href=/game-dev/part-iii/currency/ title="More Currency"><i class="fa fa-chevron-right"></i></a></div></div><div style=left:-1000px;overflow:scroll;position:absolute;top:-1000px;border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px><div style=border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px></div></div><script src=/js/clipboard.min.js?1647713367></script>
<script src=/js/perfect-scrollbar.min.js?1647713367></script>
<script src=/js/perfect-scrollbar.jquery.min.js?1647713367></script>
<script src=/js/jquery.svg.pan.zoom.js?1647713367></script>
<script src=/js/featherlight.min.js?1647713367></script>
<script src=/js/modernizr.custom-3.6.0.js?1647713367></script>
<script src=/js/mermaid.min.js?1647713367></script>
<script>typeof mermaid!="undefined"&&typeof mermaid.mermaidAPI!="undefined"&&mermaid.mermaidAPI.initialize(Object.assign({securityLevel:"antiscript"},JSON.parse('{ "startOnLoad": true }'),{startOnLoad:!1}))</script><script src=/js/relearn.js?1647713367></script></body></html>